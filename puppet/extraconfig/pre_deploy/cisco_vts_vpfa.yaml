#
# Copyright (C) 2017 cisco Inc.
#
# Author: Wojciech Dec <wdec@cisco.com>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
heat_template_version: 2015-04-30

description: Generate Cisco VTS configuration extras

parameters:
  server:
    description: ID of the controller node to apply this config to
    type: string

  # VPPparams this needs to be a json blob e.g:
  #      parameter_defaults:
  #        VPPparams: |
  #          {"ENABLE_VPP_WORKERS": True,
  #           "PCI_DRIVER": "vfio_pci"}
  VPPparams:
    type: json
    default: {}
    description: |
      json object containing VPP configuration map for VPFA Init script
      e.g.:
          VPPparams: |
            {"ENABLE_VPP_WORKERS": True,
            "PCI_DRIVER": "vfio_pci"}
  UnderlayInterface:
    description: Name of underlay interface or bond mode
    type: string
    default: ''
  BondIfList:
    description: (Optional) List of underlay interfaces to bond
    type: comma_delimited_list
    default: ''
  UnderlayIpNewtorksList:
    description: List of other underlay networks reachable through the underlay interface
    type: comma_delimited_list
    default: ''
  VPFAInit:
    description: Flag to control generation of VPFA config. Set to False if using the OSPD VPP Module.
    type: string
    default: "False"
  PerNodeData:
    description: Per node config data in json format
    type: json
    default: {}

# Install of vpfa_init.sh and dpdk_nic_bind.py is required to carry out the configuration using script.
resources:
  VTSExtraConfigPre:
    type: OS::Heat::SoftwareConfig
    properties:
      group: script
      inputs:
      - name: vpp_conf
      config: |
        #!/bin/bash
        node_id=$(dmidecode --s system-uuid | uniq)
        echo $vpp_conf > /tmp/conf_in
        echo $vpp_conf | python -c "

        # Start of Python script
        # Note: Script relies on bash variable substitution for node_id

        import ast
        from ConfigParser import SafeConfigParser, NoOptionError, NoSectionError
        import json
        import os
        import re
        import subprocess
        import six
        import sys
        import yaml
        import time

        VPFA_INIT = '/etc/vpe/vpfa/vpfa_init.sh'
        DPDK_MAP = '/var/lib/os-net-config/dpdk_mapping.yaml'
        UNDERLAY_IF_FILE = '/etc/vpe/vpfa/underlay_mac'
        HIERA_DATA = '/etc/puppet/hieradata/${node_id}.yaml'
        HIERA_SERVICE_CONFIG = '/etc/puppet/hieradata/service_configs.yaml'
        OS_NET_CONF = '/etc/os-net-config/config.json'
        LLDP_CONF='/etc/vpe/lldp/lldp.conf'

        dpdk_data = []

        def vpfa_init(env_params):
          # Launch vpfa_init script and config underlay mac
          print('Launching VPFA Init shell script')
          sproc = subprocess.Popen(VPFA_INIT.split(), env=dict(os.environ, **env_params))
          output, error = sproc.communicate()
          print('VPFA_INIT OUTPUT: {0}  ERROR: {1}'.format(output, error))

        def load_dpdk_data(file):
          global dpdk_data
          with open(file) as f:
            try:
              dpdk_data = yaml.load(f)
            except yaml.YAMLError as exc:
              print(exc)

        def mac_underlay_init(env_params, underlay_intf):
          # Assuming VPP configured by os-net-config module. Configure only underlay mac address file.

          print('Configuring underlay mac address for vpfa')
          for interface in dpdk_data:
            if 'name' in interface and interface['name'] == underlay_intf:
              underlay_mac = interface['mac_address']
              print('CustomVPFA Extra Config found underlay MAC address: {0}'
                    ' for interface: {1}'.format(underlay_mac, interface['name']))
              break
          else:
            print('CustomVPFA Extra Config unable to '
                  'find dpdk_map MAC address for: {0}'.format(underlay_intf))
            return
            
          with open(UNDERLAY_IF_FILE, 'w') as umac_file:
            try:
              umac_file.write(underlay_mac)
              print('VPFA Extra Config wrote underlay mac file - OK')
            except IOError as e:
              print('VPFA Extra Config underlay mac file error: {}'.format(str(e)))

        def write_node_data(env_params):
          print('Extracting node specific data for vpfa and generating hiera file')
          node_env = env_params.get('NODE_DATA', {}).get('${node_id}', {})
          with open(HIERA_DATA, 'w') as hierafile:
            try:
              yaml.safe_dump(node_env, hierafile, default_flow_style=False)
            except IOError as e:
              print('VPFA Extra Config node data file error: {}'.format(str(e)))

        def get_interfaces():
          # Get VPP interface data from Os Net config, combine it with DPDK map info and sort based on PCI address
          print('Getting and augementing VPP interface data')
          target_interfaces = []
          with open(OS_NET_CONF) as os_net_conf:
            try:
              config = json.load(os_net_conf)
              interfaces = config['network_config']
            except IOError as e:
              print('VPFA Extra Config os-net-config file error: {}'.format(str(e)))
          for i in interfaces:
            if i.get('type') in ['vpp_bond', 'vpp_interface']:
              target_interfaces.append(i)

          # This adds the pci_address key to the simple vpp_interfaces
          target_interfaces = merge_lists(target_interfaces, dpdk_data, 'name')
          target_interfaces = sorted(target_interfaces, key=lambda x: x.get('pci_address'))

          # This adds the pci_address key to the simple vpp_bond interfaces and sorts
          for i in target_interfaces:
            if i['type'] == 'vpp_bond':
              _ = merge_lists(i['members'], dpdk_data, 'name')
              i['members'] = sorted(_, key=lambda x: x.get('pci_address'))
          #print('Target VPP Interfaces SORTED', target_interfaces)
          return target_interfaces

        def update_with_intf_names(env_params, interfaces = []):
          print('Extracting node vpp interface configuration')
          config = {}
          env_params['NODE_DATA']['${node_id}'].update({'cisco_vpfa::bond_if_list': [] })
          env_params['NODE_DATA']['${node_id}'].update({'cisco_vpfa::underlay_interface': [] })
          for i in interfaces:
            if i['type'] == 'vpp_bond':
              bond_nr = re.sub('[^0-9]','',i['name'])
              env_params['NODE_DATA']['${node_id}']['cisco_vpfa::underlay_interface'].append('bond'+bond_nr)
              for member in i['members']:
                # NOTE: This requires a change indexing bonds when supporting multiple bonds
                env_params['NODE_DATA']['${node_id}']['cisco_vpfa::bond_if_list'].append(member['name'])
            if i['type'] == 'vpp_interface':
              env_params['NODE_DATA']['${node_id}']['cisco_vpfa::underlay_interface'].append(i['name'])
          return env_params

        def update_with_lldp(env_params, interfaces = []):
          # First Check if LLDP is meant to be configured
          with open(HIERA_SERVICE_CONFIG, 'r') as hiera_service_c:
            try:
              config = yaml.load(hiera_service_c)
            except IOError as e:
              print('VPFA Extra Config os-net-config file error: {}'.format(str(e)))
          if 'vts::lldp_enable' in config and config['vts::lldp_enable'] == True:
            print('Adding VPP LLDP config')
            # Add VPP LLDP enable command parametrized with puppet %fqdn fact
            env_params['NODE_DATA']['${node_id}'].update({'fdio::vpp_exec_commands':
                      ['set lldp system-name %{::fqdn} tx-hold 4 tx-interval 30'] })

            # Get the same IPv4 and IPv6 management addresses as used in the system LLDPD config
            lldp_mngmnt_ipv4 = '%{::ipaddress}'
            lldp_mngmnt_ipv6 = '%{::ipaddress6}'
            parser = SafeConfigParser()
            parser.read(LLDP_CONF)
            try:
              lldp_mngmnt_ipv4 = parser.get('DEFAULT', 'MGMT_IP4_ADDR')
              lldp_mngmnt_ipv6 = parser.get('DEFAULT', 'MGMT_IP6_ADDR')
            except (NoOptionError, NoSectionError) as e:
              print('WARNING: Couldn\'t obtain VTS LLDP management IP configuration: {}'.format(str(e)))
              print('Will use facter\'s default IP for LLDP management IP addresses.')

            index_hack = 2


            for i in interfaces:
              if i['type'] == 'vpp_bond':
                for member in i['members']:
                  env_params['NODE_DATA']['${node_id}']['fdio::vpp_exec_commands'].append(
                    'set interface lldp sw_if_index ' + str(index_hack) + ' port-desc vtf:' + member['name'] + ' '
                    + lldp_mngmnt_ipv4 + ' ' + lldp_mngmnt_ipv6)
                  index_hack += 1
                # NOTE: This requires a change when supporting multiple bonds
                break
                #return env_params
              if i['type'] == 'vpp_interface':
                env_params['NODE_DATA']['${node_id}']['fdio::vpp_exec_commands'].append(
                  'set interface lldp sw_if_index ' + str(index_hack) + ' port-desc vtf:' + i['name'])
                index_hack += 1

          return env_params

        def merge_lists(l1, l2, key):
          # Returns dict list l1 with additional data from dict list l2 only for shared keys, if any.
          kvals_l2 = [x.get(key) for x in l2]
          merged = {}
          for item in l1:
            merged[item[key]] = item
            if item[key] not in kvals_l2:
              continue
            for item2 in l2:
              if item[key] == item2[key]:
                merged[item[key]].update(item2)
          return [val for (_, val) in merged.items()]


        #### Main script
        print('\n*****************************************')
        print('Cisco VTS Extra Pre Deployment script run')
        print(time.strftime('%c'))
        print('*****************************************\n')

        input = sys.stdin.readline() or '{}'
        input = ast.literal_eval(input)
        env_params = dict()
        for i in input:
          env_params.update(i)

        vpp_params = env_params.pop('VPP_PARAMS', {})
        if isinstance(vpp_params, dict):
          for k, v in six.iteritems(vpp_params):
            env_params[k] = v
        for k, v in six.iteritems(env_params):
          if isinstance(v, list):
            v = ','.join(v)
            env_params[k] = v

        # Create empty per-node data unless already present
        if '${node_id}' not in env_params['NODE_DATA']:
          env_params['NODE_DATA']['${node_id}'] = {}

        if 'VPFA_INIT' in env_params and env_params['VPFA_INIT'] == True:
          # VPP config will be generated by vpfa_init script
          vpfa_init(env_params)
        else:
          # VPP Config will be done by puppet. Need to add some config from os_net_conf data however.
          load_dpdk_data(DPDK_MAP)
          vpp_interfaces = get_interfaces()
          env_params = update_with_intf_names(env_params, vpp_interfaces)

          # The u_interface is taken to be the first one from the cisco_vpfa::underlay_interface
          # or the the cisco_vpfa::bond_if_list in case of bonding
          underlay_intf = ''
          if 'NODE_DATA' in env_params and '${node_id}' in env_params['NODE_DATA']:
            underlay_intf = env_params['NODE_DATA']['${node_id}']['cisco_vpfa::underlay_interface'][0]
          if 'bond' in underlay_intf:
            underlay_intf = env_params['NODE_DATA']['${node_id}']['cisco_vpfa::bond_if_list'][0]

          mac_underlay_init(env_params, underlay_intf)
          env_params = update_with_lldp(env_params, vpp_interfaces)

        write_node_data(env_params)

        # End of Python script

        " >> /var/log/vpfa/vts_extra_config_pre_out


  VTSExtraDeploymentPre:
    type: OS::Heat::SoftwareDeployment
    properties:
      name: Cisco_VPFA_ExtraConfig
      config: {get_resource: VTSExtraConfigPre}
      server: {get_param: server}
      actions: ['CREATE','UPDATE']
      input_values:
        vpp_conf:
            - NODE_DATA: {get_param: PerNodeData}
            - VPP_PARAMS: {get_param: VPPparams}
            - UNDERLAY_IF_NAME: {get_param: UnderlayInterface}
            - BOND_IF_LIST: {get_param: BondIfList }
            - UNDERLAY_IP_NET_LIST: {get_param: UnderlayIpNewtorksList}
            - VPFA_INIT: {get_param: VPFAInit}

outputs:
  deploy_stdout:
    description: Deployment reference, used to trigger puppet apply on changes
    value: {get_attr: [VTSExtraDeploymentPre, deploy_stdout]}
